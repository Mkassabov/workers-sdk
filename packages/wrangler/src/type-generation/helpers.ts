import assert from "assert";
import { readFileSync } from "fs";
import { version } from "workerd";
import yargs from "yargs";
import { readConfig } from "../config";
import { getRuntimeHeader } from "./runtime";
import { generateEnvTypes, getEntrypointsFromConfigs } from ".";
import type { typesCommand } from ".";
import type { Config } from "../config";

/**
 * Checks the default location for a generated types file and compares if the
 * recorded Env hash, workerd version or compat date and flags have changed
 * compared to the current values in the config. Prompts user to re-run wrangler
 * types if so.
 */

export const checkTypesDiff = async (
	primaryConfig: Config,
	typesPath = "./worker-configuration.d.ts"
) => {
	const typesFileLines = readFileSync(typesPath, "utf-8").split("\n");

	const existingEnvHeader = typesFileLines.find((line) =>
		line.startsWith("// Generated by Wrangler")
	);

	// we don't want to check types that are not generated by wrangler
	if (!existingEnvHeader) {
		return;
	}

	const matches = existingEnvHeader?.match(
		/\/\/ Generated by Wrangler by running `(?<command>.*)` \(hash: (?<hash>[a-zA-Z0-9]+)\)/
	)?.groups;
	const wranglerCommand = matches?.command ?? "";

	const maybeExistingHash = matches?.hash;

	// does not have aliases and defaults automatically :(
	const rawArgs = yargs(wranglerCommand).parse() as Partial<
		typeof typesCommand.args
	> & { c: string[]; config: string[] };
	const args = {
		...rawArgs,
		config: rawArgs.config ?? rawArgs.c ?? [],
		includeEnv: rawArgs.includeEnv ?? true,
		includeRuntime: rawArgs.includeRuntime ?? true,
		envInterface: rawArgs.envInterface ?? "Env",
		strictVars: rawArgs.strictVars ?? true,
	} as Partial<typeof typesCommand.args> & { c: string[]; config: string[] };

	const secondaryConfigs: Config[] = [];
	if (Array.isArray(args.config)) {
		for (const configPath of args.config.slice(1)) {
			secondaryConfigs.push(readConfig({ config: configPath }));
		}
	}

	const { entrypoint, secondaryEntries } = await getEntrypointsFromConfigs(
		primaryConfig,
		secondaryConfigs
	);
	let envOutOfDate = false;

	if (args.includeEnv !== false) {
		const { envHeader } = await generateEnvTypes(
			primaryConfig,
			args,
			entrypoint,
			secondaryEntries,
			false
		);
		const newHash = envHeader?.match(/hash: (?<hash>.*)\)/)?.groups?.hash;

		envOutOfDate = maybeExistingHash !== newHash;
	}

	let runtimeOutOfDate = false;
	if (args.includeRuntime !== false) {
		assert(
			primaryConfig.compatibility_date,
			"Config must have a compatibility date."
		);
		const header = getRuntimeHeader(
			version,
			primaryConfig.compatibility_date,
			primaryConfig.compatibility_flags
		);
		const existingHeader = typesFileLines.find((line) =>
			line.startsWith("// Runtime types generated with workerd@")
		);
		runtimeOutOfDate = header !== existingHeader;
	}

	return envOutOfDate || runtimeOutOfDate;
};
