import assert from "assert";
import { readFileSync } from "fs";
import { version } from "workerd";
import yargs from "yargs";
import { readConfig } from "../config";
import { UserError } from "../errors";
import { getRuntimeHeader } from "./runtime";
import { generateEnvTypes, getEntrypointsFromConfigs } from ".";
import type { typesCommand } from ".";
import type { Config } from "../config";

/**
 * Checks the default location for a generated types file and compares if the
 * recorded Env hash, workerd version or compat date and flags have changed
 * compared to the current values in the config. Prompts user to re-run wrangler
 * types if so.
 * All of this assumes that the headers accurately reflect the generated content.
 */

export const checkTypesDiff = async (
	primaryConfig: Config,
	typesPath = "./worker-configuration.d.ts"
) => {
	const typesFileLines = readFileSync(typesPath, "utf-8").split("\n");

	const existingEnvHeader = typesFileLines.find((line) =>
		line.startsWith("// Generated by Wrangler")
	);

	// We don't want to check types that are not generated by Wrangler
	if (!existingEnvHeader) {
		throw new UserError(`No generated types found in ${typesPath}.`);
	}

	const matches = existingEnvHeader?.match(
		/\/\/ Generated by Wrangler by running `(?<command>.*)` \(hash: (?<hash>[a-zA-Z0-9]+)\)/
	)?.groups;
	const wranglerCommand = matches?.command ?? "";
	const maybeExistingHash = matches?.hash;

	// does not have aliases and defaults automatically :(
	const rawArgs = yargs(wranglerCommand).parse() as Record<string, unknown>;
	const args = {
		config: rawArgs.config ?? rawArgs.c ?? [],
		includeEnv: stringToBoolean(rawArgs.includeEnv ?? "true"),
		includeRuntime: stringToBoolean(rawArgs.includeRuntime ?? "true"),
		envInterface: rawArgs.envInterface ?? "Env",
		strictVars: stringToBoolean(rawArgs.strictVars ?? "true"),
	} as Partial<typeof typesCommand.args> & { c: string[]; config: string[] };

	const secondaryConfigs: Config[] = [];
	if (Array.isArray(args.config)) {
		for (const configPath of args.config.slice(1)) {
			secondaryConfigs.push(readConfig({ config: configPath }));
		}
	}

	const { entrypoint, secondaryEntries } = await getEntrypointsFromConfigs(
		primaryConfig,
		secondaryConfigs
	);
	let envOutOfDate = false;

	if (args.includeEnv !== false) {
		const { envHash } = await generateEnvTypes(
			primaryConfig,
			args,
			entrypoint,
			secondaryEntries,
			false
		);
		envOutOfDate = maybeExistingHash !== envHash;
	}

	let runtimeOutOfDate = false;
	if (args.includeRuntime !== false) {
		assert(
			primaryConfig.compatibility_date,
			"Config must have a compatibility date."
		);
		const header = getRuntimeHeader(
			version,
			primaryConfig.compatibility_date,
			primaryConfig.compatibility_flags
		);
		const existingHeader = typesFileLines.find((line) =>
			line.startsWith("// Runtime types generated with workerd@")
		);
		runtimeOutOfDate = header !== existingHeader;
	}

	return envOutOfDate || runtimeOutOfDate;
};

const stringToBoolean = (value: unknown): boolean => {
	if (typeof value === "string") {
		if (value.toLowerCase() === "true") {
			return true;
		}
		if (value.toLowerCase() === "false") {
			return false;
		}
	}
	throw new Error(`Invalid value: ${value}`);
};
