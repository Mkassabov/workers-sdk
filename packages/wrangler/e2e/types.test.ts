import { readFileSync } from "node:fs";
import { writeFile } from "node:fs/promises";
import path from "node:path";
import { beforeEach, describe, expect, it } from "vitest";
import { dedent } from "../src/utils/dedent";
import { WranglerE2ETestHelper } from "./helpers/e2e-wrangler-test";

const baseConfig = dedent`
name = "test-worker"
main = "src/index.ts"
compatibility_date = "2023-01-01"
compatibility_flags = ["nodejs_compat", "no_global_navigator"]
[vars]
MY_VAR = "my-var-value"
`;
const seed = {
	"wrangler.toml": baseConfig,
	"src/index.ts": dedent`
		export default {
			fetch(request) {
				return new Response("Hello World!")
			}
		}
	`,
	"package.json": dedent`
		{
			"name": "test-worker",
			"version": "0.0.0",
			"private": true
		}
	`,
};

describe("types", () => {
	let helper: WranglerE2ETestHelper;
	beforeEach(async () => {
		helper = new WranglerE2ETestHelper();
		await helper.seed(seed);
	});
	it("should generate runtime types without a flag", async () => {
		const output = await helper.run(`wrangler types`);

		expect(output.stdout).toContain("Generating runtime types...");
		expect(output.stdout).toContain("Runtime types generated.");
		expect(output.stdout).toContain(
			"✨ Types written to worker-configuration.d.ts"
		);
		expect(output.stdout).toContain("📖 Read about runtime types");
	});

	it("should generate runtime types and env types in one file at the default path", async () => {
		const output = await helper.run(`wrangler types`);
		expect(output.stdout).toContain("Generating project types...");
		expect(output.stdout).toContain("interface Env {");
		expect(output.stdout).toContain("Generating runtime types...");
		expect(output.stdout).toContain("Runtime types generated.");
		expect(output.stdout).toContain(
			"✨ Types written to worker-configuration.d.ts"
		);
		const file = readFileSync(
			path.join(helper.tmpPath, "./worker-configuration.d.ts"),
			"utf8"
		);
		expect(file).matches(/declare module ['"]cloudflare:workers["']/);
		expect(file).contains("interface Env");
	});

	it("should be able to generate an Env type only", async () => {
		const output = await helper.run(`wrangler types --include-runtime=false`);
		expect(output.stdout).not.toContain("Generating runtime types...");
		const file = readFileSync(
			path.join(helper.tmpPath, "./worker-configuration.d.ts"),
			"utf8"
		);
		expect(file).toMatchInlineSnapshot(`
			"/* eslint-disable */
			// Generated by Wrangler by running \`wrangler types --include-runtime=false\` (hash: 7915eccca244b8d5c107e358ee5929e8)
			declare namespace Cloudflare {
				interface Env {
					MY_VAR: "my-var-value";
				}
			}
			interface Env extends Cloudflare.Env {}
			"
		`);
	});

	it("should include header with version information in the generated types", async () => {
		await helper.run(`wrangler types "./types.d.ts" `);

		const lines = readFileSync(
			path.join(helper.tmpPath, "./types.d.ts"),
			"utf8"
		).split("\n");

		expect(lines[1]).toMatchInlineSnapshot(
			`"// Generated by Wrangler by running \`wrangler types ./types.d.ts\` (hash: 7915eccca244b8d5c107e358ee5929e8)"`
		);
		expect(lines[2]).match(
			/\/\/ Runtime types generated with workerd@1\.\d{8}\.\d \d{4}-\d{2}-\d{2} ([a-z_]+,?)*/
		);
	});

	it("should include header with wrangler command that generated it", async () => {
		await helper.seed({
			...seed,
			"wranglerA.toml": dedent`
			name = "test-worker"
			main = "src/index.ts"
			compatibility_date = "2023-01-01"
		`,
		});
		await helper.run(
			"wrangler types -c wranglerA.toml --env-interface MyCloudflareEnv ./cflare-env.d.ts"
		);

		const lines = readFileSync(
			path.join(helper.tmpPath, "./cflare-env.d.ts"),
			"utf8"
		).split("\n");

		expect(lines[1]).toMatchInlineSnapshot(
			`"// Generated by Wrangler by running \`wrangler types -c wranglerA.toml --env-interface MyCloudflareEnv ./cflare-env.d.ts\` (hash: fb913b8eb739817c9664fa1da8bdf499)"`
		);
		expect(lines[2]).match(
			/\/\/ Runtime types generated with workerd@1\.\d{8}\.\d \d{4}-\d{2}-\d{2} ([a-z_]+,?)*/
		);
	});

	it("should not regenerate runtime types if the header matches, but should regenerate env types", async () => {
		await helper.run(`wrangler types`);

		const typesPath = path.join(helper.tmpPath, "worker-configuration.d.ts");
		const file = readFileSync(typesPath, "utf8").split("\n");

		await writeFile(
			typesPath,
			[
				file[0],
				file[1],
				file[2],
				"FAKE ENV",
				"// Begin runtime types",
				"FAKE RUNTIME",
			].join("\n")
		);

		await helper.run(`wrangler types`);

		const file2 = readFileSync(typesPath, "utf8");

		// regenerates env types
		expect(file2).toContain("interface Env {");
		// uses cached runtime types
		expect(file2).toContain("// Begin runtime types");
		expect(file2).toContain("FAKE RUNTIME");
	});

	it("should prompt you to update types if types have changed during dev", async () => {
		await helper.run(`wrangler types`);
		let newConfig = dedent`
				name = "test-worker"
				main = "src/index.ts"
				compatibility_date = "2023-01-01"
				compatibility_flags = ["nodejs_compat", "no_global_navigator"]
				[vars]
				BEEP = "BOOP"
			`;
		await helper.seed({ ...seed, "wrangler.toml": newConfig });
		const worker = helper.runLongLived("wrangler dev");
		await worker.readUntil(/❓ Your types might be out of date./);
		// error goes away when reset
		await helper.seed({ ...seed, "wrangler.toml": baseConfig });
		await expect(
			worker.readUntil(/❓ Your types might be out of date./, 5_000)
		).rejects.toThrowError();

		// change runtime types
		newConfig = dedent`
			name = "test-worker"
			main = "src/index.ts"
			compatibility_date = "2023-01-01"
			compatibility_flags = ["nodejs_compat"]
			[vars]
			MY_VAR = "my-var-value"
		`;
		await helper.seed({ ...seed, "wrangler.toml": newConfig });
		await worker.readUntil(/❓ Your types might be out of date./);
		// error goes away when reset
		await helper.seed({ ...seed, "wrangler.toml": baseConfig });
		await expect(
			worker.readUntil(/❓ Your types might be out of date./, 5_000)
		).rejects.toThrowError();
	});

	it("should error on running `wrangler types --check` if env changes", async () => {
		await helper.run(`wrangler types`);

		const newConfig = dedent`
				name = "test-worker"
				main = "src/index.ts"
				compatibility_date = "2023-01-01"
				compatibility_flags = ["nodejs_compat", "no_global_navigator"]
				[vars]
				BEEP = "BOOP"
			`;
		await helper.seed({ ...seed, "wrangler.toml": newConfig });
		const output = await helper.run(`wrangler types --check`);
		expect(output.stderr).toContain("out of date");
	});

	it("should error on running `wrangler types --check` if runtime types change", async () => {
		await helper.run(`wrangler types`);

		const newConfig = dedent`
				name = "test-worker"
				main = "src/index.ts"
				compatibility_date = "2023-01-01"
				compatibility_flags = ["nodejs_compat"]
				[vars]
				MY_VAR = "my-var-value"
			`;
		await helper.seed({ ...seed, "wrangler.toml": newConfig });
		const output = await helper.run(`wrangler types --check`);
		expect(output.stderr).toContain("out of date");
	});

	it("should not error on `wrangler types --check` if types are up to date", async () => {
		await helper.run(`wrangler types`);
		let output = await helper.run(`wrangler types --check`);
		expect(output.stderr).toBeFalsy();

		await helper.run(`wrangler types --include-env=false`);
		output = await helper.run(`wrangler types --check`);
		expect(output.stderr).toBeFalsy();

		await helper.run(`wrangler types --include-runtime=false`);
		output = await helper.run(`wrangler types --check`);
		expect(output.stderr).toBeFalsy();

		await helper.run(`wrangler types ./custom.d.ts`);
		output = await helper.run(`wrangler types ./custom.d.ts --check`);
		expect(output.stderr).toBeFalsy();
		expect(output.stdout).toContain(
			`✨ Types at ./custom.d.ts are up to date.`
		);
	});
});
