import { existsSync } from "fs";
import { join } from "path";
import { warn } from "@cloudflare/cli";
import { brandColor, dim } from "@cloudflare/cli/colors";
import { runCommand } from "helpers/command";
import { readFile, usesTypescript, writeFile } from "helpers/files";
import { detectPackageManager } from "helpers/packageManagers";
import * as jsonc from "jsonc-parser";
import type { C3Context } from "types";

/**
 * Generate types using `wrangler types` and update tsconfig
 */
export async function generateWorkersTypes(ctx: C3Context) {
	if (!usesTypescript(ctx)) {
		return;
	}
	const { npm } = detectPackageManager();
	const typesCmd = [npm, "run", ctx.template.typeGenScript ?? "cf-typegen"];

	await runCommand(typesCmd, {
		cwd: ctx.project.path,
		silent: true,
		env: {
			CLOUDFLARE_ACCOUNT_ID: ctx.account?.id,
			NODE_ENV: "production",
		},
		startText: "Generating types for your application",
		doneText: `${brandColor("generated")} ${dim(`to \`${ctx.template.typesPath}\` via \`${typesCmd.join(" ")}\``)}`,
	});
	await addWorkersTypesToTsConfig(ctx);
}

export async function addWorkersTypesToTsConfig(ctx: C3Context) {
	const tsconfigPath = join(ctx.project.path, "tsconfig.json");
	if (!existsSync(tsconfigPath)) {
		return;
	}

	// const s = spinner();
	// s.start("Adding generated types to `tsconfig.json`");

	const tsconfig = readFile(tsconfigPath);
	// const entrypointVersion = getLatestTypesEntrypoint(ctx);
	// if (entrypointVersion === null) {
	// 	s.stop(
	// 		`${brandColor(
	// 			"skipped",
	// 		)} couldn't find latest compatible version of @cloudflare/workers-types`,
	// 	);
	// 	return;
	// }

	// const typesEntrypoint = `@cloudflare/workers-types/${entrypointVersion}`;

	try {
		const config = jsonc.parse(tsconfig);
		const currentTypes = config.compilerOptions?.types ?? [];

		const newTypes = [
			...currentTypes.filter(
				(t: string) => !t.startsWith("@cloudflare/workers-types"),
			),
			"./worker-configuration.d.ts",
		];

		// If we detect any tabs, use tabs, otherwise use spaces.
		// We need to pass an explicit value here in order to preserve formatting properly.
		const useSpaces = !tsconfig.match(/\t/g);

		// Calculate required edits and apply them to file
		const edits = jsonc.modify(
			tsconfig,
			["compilerOptions", "types"],
			newTypes,
			{
				formattingOptions: { insertSpaces: useSpaces },
			},
		);
		const updated = jsonc.applyEdits(tsconfig, edits);
		writeFile(tsconfigPath, updated);
	} catch (error) {
		warn(
			"Failed to update `tsconfig.json` with types generated by `wrangler types` entrypoint.",
		);
	}
}
